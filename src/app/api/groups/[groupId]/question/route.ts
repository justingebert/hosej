import dbConnect from "@/lib/dbConnect";import Question from "@/db/models/Question";import User from "@/db/models/user";import { type NextRequest, NextResponse } from "next/server";import Chat from "@/db/models/Chat";import Group from "@/db/models/Group";import { isUserInGroup } from "@/lib/groupAuth";import { CREATED_QUESTION_POINTS } from "@/db/POINT_CONFIG";import { ValidationError } from "@/lib/api/errorHandling";import { AuthedContext, withAuthAndErrors } from "@/lib/api/withAuth";import { generateSignedUrl } from "@/lib/generateSingledUrl";import { QuestionDTO } from "@/types/models/question";export const revalidate = 0;export const POST = withAuthAndErrors(    async (        req: NextRequest,        {params, userId}: { params: { groupId: string }; userId: string }    ) => {        const {groupId} = params;        await dbConnect();        await isUserInGroup(userId, groupId);        const data = await req.json();        const {category, questionType, question, submittedBy, image} = data;        if (!groupId || !category || !questionType || !question || !submittedBy) {            throw new ValidationError("Missing required fields");        }        // Populate options based on question type        let options = data.options || [];        if (questionType.startsWith("users-") && options.length === 0) {            const group = await Group.findById(groupId);            options = group.members.map((member: any) => member.name);        } else if (questionType.startsWith("rating") && options.length === 0) {            options = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];        }        const newQuestion = new Question({            groupId: groupId,            category: category,            questionType: questionType,            question: question,            image: image,            options: options,            submittedBy: submittedBy,        });        await newQuestion.save();        const newChat = new Chat({            group: groupId,            entity: newQuestion._id,            entityModel: "Question",            messages: [],        });        await newChat.save();        newQuestion.chat = newChat._id;        await newQuestion.save();        //TODO pass from context        const group = await Group.findById(groupId);        const submittingUser = await User.findById(submittedBy);        await group.addPoints(submittingUser._id, CREATED_QUESTION_POINTS);        return NextResponse.json({newQuestion}, {status: 201});    });type UserRating = "good" | "ok" | "bad" | nulltype QuestionWithUserState = QuestionDTO & {    userHasVoted: boolean;    userRating: UserRating;};// Return active daily questionsexport const GET = withAuthAndErrors(async (req: NextRequest, {params, userId}: AuthedContext<{    params: { groupId: string }}>) => {    const {groupId} = params;    await dbConnect();    await isUserInGroup(userId, groupId);    let questions = await Question.find({        groupId: groupId,        category: "Daily",        used: true,        active: true,    }).lean();    if (!questions || questions.length === 0) {        return NextResponse.json({questions: [], message: "No questions available"});    }    const group = await Group.findById(groupId);    const userCount = group.members.length;    const totalVotes = questions.reduce(        (acc, question) => acc + (question.answers?.length || 0),        0    );    const completionPercentage = ((totalVotes / (questions.length * userCount)) * 100).toFixed(        0    );    const questionsPopulated = questions.map((q) => {        const userHasVoted =            q.answers?.some((a) => a.user.toString() === userId) ?? false;        const userRating: UserRating =            q.rating.good.some((id) => id.toString() === userId)                ? "good"                : q.rating.ok.some((id) => id.toString() === userId)                    ? "ok"                    : q.rating.bad.some((id) => id.toString() === userId)                        ? "bad"                        : null;        // return a new object with computed fields        return { ...q, userHasVoted, userRating };    });    const questionsWithImages = await Promise.all(        questionsPopulated.map(async (question) => {            if (question.image) {                const {url} = await generateSignedUrl(new URL(question.image).pathname);                question.imageUrl = url;            }            if (question.questionType.startsWith("image")) {                question.options = await Promise.all(                    question.options.map(async (option: any) => {                        if (!option.key) throw new Error("Option is empty");                        return await generateSignedUrl(option.key, 60);                    })                );            }            return question;        })    );    return NextResponse.json({questions: questionsWithImages, completionPercentage});});